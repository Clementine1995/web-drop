# CSS揭秘学习

## 背景与边框

### 半透明边框

假设我们想给一个容器设置一层白色背景和一道半透明白色边框，body 的背景会从它的半透明边框透上来。我们最开始的尝试可能是这样的

```css
border: 10px solid hsla(0,0%,100%,.5);
background: white;
```

但是实际上，并没有出现半透明边框，造成这个现象的原因是，background默认是从border开始的，通过设置虚线border就可以发现这一点。

解决办法就是通过 background-clip 属性来调整上述默认行为所带来的不便。这个属性的初始值是 border-box，意味着背景会被元素的 border box（边框的外沿框）裁切掉。如果不希望背景侵入边框所在的范围，把它的值设为 padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。

### 多重边框

#### box-shadow 方案

利用 box-shadow 第四个参数（称作“扩张半径”），通过指定正值或负值，可以让投影面积加大或者减小。一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的“投影”其实就像一道实线边框.

这并没有什么了不起的，因为你完全可以用 border 属性来生成完全一样的边框效果。不过 box-shadow 的好处在于，它支持**逗号分隔语法**，可以创建任意数量的投影。

唯一需要注意的是，box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。多重投影解决方案在绝大多数场合都可以很好地工作，但有一些注意事项。

+ 投影的行为跟边框不完全一致，因为它不会影响布局，而且也不会 受到 box-sizing 属性的影响。不过，你还是可以通过内边距或外边 距（这取决于投影是内嵌和还是外扩的）来额外模拟出边框所需要 占据的空间。
+ 上述方法所创建出的假“边框”出现在元素的外圈。它们并不会响 应鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给 box-shadow 属性加上 inset 关键字，来使投影绘制在元素的内圈。 请注意，此时你需要增加额外的内边距来腾出足够的空隙。

#### outline 方案

在某些情况下，你可能只需要两层边框，那就可以先设置一层常规边框，再加上 outline（描边）属性来产生外层的边框。这种方法的一大优点在于边框样式十分灵活，不像上面的 box-shadow 方案只能模拟实线边框（假设我们需要产生虚线边框效果，box-shadow 就没辙了）。

描边的另一个好处在于，你可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，这个属性甚至可以接受负值。对一层 dashed（虚线）描边使用 负的outline-offset 后，可以得到简单的缝边效果.

这个方案同样也有一些需要注意的地方。

+ 只适用于双层“边框”的场景，因为 outline 并不能 接受用逗号分隔的多个值。
+ 边框不一定会贴合 border-radius 属性产生的圆角，因此如果元素 是圆角的，它的描边可能还是直角
+ 描边可以不是矩形

### 灵活的背景定位

#### background-position 的扩展语法方案

background-position 属性已经得到扩展，它允许我们指定背景图片距离任 意角的偏移量，只要我们在偏移量前面指定关键字。举例来说，如果想让背 景图片跟右边缘保持 20px 的偏移量，同时跟底边保持 10px 的偏移量，可以 这样做（结果如图 2-11 所示）：

```css
background: url(code-pirate.svg) no-repeat #58a;
background-position: right 20px bottom 10px;
```

#### background-origin 方案

background-position 是以 padding box 为准的，这样边框才不会遮住背景图片。因此，top left 默认指的是 padding box 的左上角。不过，在背景与边框（第三版）中， 我们得到了一个新的属性 background-origin，可以用它来改变这种行为。 在默认情况下，它的值是padding-box。如果把它的值改成 content-box（参见下面的代码），我们在 background-position 属性中使用的边角关键字将会以内容区的边缘作为基准。

#### calc() 方案

### 边框内圆角

有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状，如何只用一个元素达成同样的效果呢？

```css
background: tan;
border-radius: .8em;
padding: 1em;
box-shadow: 0 0 0 .6em #655;
outline: .6em solid #655;
```

描边并不会跟着元素的圆角走（因而显示出直角），但 box-shadow 却是会的。因此，如果我们把这两者叠加到一起，box-shadow 会刚好填补描边和容器圆角之间的空隙，这两者的组合达成了我们想要的效果。为了让这个效果得 以达成，扩张半径需要比描边的宽度值小，但它同时又要比(根2 - 1)r − 大。

### 条纹背景

在线性渐变里，如果把两个色标重合在一起，就会产生条纹的效果，再通过 background-size 来调整其尺寸，由于背景在默认情况下是重复平铺的，整个容器其实已经被填满了水平条纹。

```css
background: linear-gradient(#fb3 50%, #58a 50%);
background-size: 100% 30px;
```

为了避免每次改动条纹宽度时都要修改两个数字，我们可以再次从规范那里找到捷径。第二个色标的位置值设置为 0，那它的位置就总是会被浏览器调整为前一个色标的位置值。如果要创建超过两种颜色的条纹，也是很容易的。举例来说，下面的代 码可以生成三种颜色的水平条纹：

```css
background: linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0);
background-size: 100% 45px;
```
