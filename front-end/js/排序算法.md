# 排序算法JS实现

> 参考自[**超详细的**10种排序算法原理及 JS 实现](https://juejin.im/post/5c9cf808f265da611846c015)

## 基本概念

1.啥是排序？

排序是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作。

2.排序的稳定性

先来看官方解释：当排序记录中的关键字K[i](i=1, 2, ···, n)都不相同时，则任何一个记录的无序序列经过排序后的得到的结果唯一；反之，当待排序的序列中存在两个或者两个以上关键字相等的记录时，则排序所的得到的结果不唯一。假设K[i] = K[j](1<=i<=n, 1<=j<=n, i!=j)，且在排序前的序列中R[i]领先于R[j]，若在排序后的序列中R[i]仍领先于R[j]，则称所用的排序方法是稳定的；反之，若可能使排序后的序列中R[j]领先于R[i]，则称所用的排序方法是不稳定的。

简单来说像a = [6, 3, 4, 6, 5]这个数组来说，a[0]的6在a[3]的6之前，如果排序后a[0]可以保证仍然在a[3]之前，那么这个排序算法就是稳定的。

不稳定的排序算法并不能说它不好，各有各的适用场合。

3.分类

+ 冒泡排序
+ 选择排序
  + 简单选择排序
  + 堆排序
+ 插入排序
  + 直接插入排序
  + 希尔排序
+ 快速排序
+ 归并排序
+ 计数排序
+ 桶排序
+ 基数排序

4.复杂度和稳定性

|名称|平均时间复杂度|最好|最坏|空间复杂度|稳定性|
|----|------------|---|----|---------|-----|
|冒泡排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定|
|简单选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定|
|堆排序|O(n logn)|O(n logn)|O(n logn)|O(1)|不稳定|
|直接插入排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定|
|希尔排序|O(n logn)|O(n log^2 n)|O(n log^2 n)|O(1)|不稳定|
|快速排序|O(n logn)|O(n logn)|O(n^2)|O(logn)|不稳定|
|归并排序|O(n logn)|O(n logn)|O(n logn)|O(n)|稳定|
|计数排序|O(n+k)|O(n+k)|O(n+k)|O(k)|稳定|
|桶排序|O(n+k)|O(n+k)|O(n^2)|O(n+k)|稳定|
|基数排序|O(n*k)|O(n*k)|O(n*k)|O(n+k)|稳定|

## 冒泡排序（Bubble Sort）

### 一般实现

算法步骤：

1. 设待排序数组r[1···n]，首先将第一个记录的关键字与第二个记录的关键字进行比较，如果r[1]>r[2]，则交换他们，然后比较第二个与第三个，以此类推直至第n-1个记录与第n个进行过比较为止
2. 对前n-1个记录执行1操作，每次遍历结束都可以找到最大的记录。
3. 重复上述比较和交换过程，如果一趟排序中没有进行过交换证明序列已达到要求。

演示图：

![冒泡](https://user-gold-cdn.xitu.io/2019/3/29/169c901fbe75639b?imageslim)

```js
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length -1 - i; j++) {
      if (arr[j] > arr[j+1]) swap(arr, j ,j+1)
    }
  }
  return arr
}

function swap(arr, n, m) {
  [arr[n], arr[m]] = [arr[m], arr[n]]
}
```

### 优化（减少外层遍历次数）

检查某次内层遍历是否发生交换。

如果没有发生交换，说明已经排序完成，就算外层循环还没有执行完 length-1 次也可以直接 break。

```js
function bubbleSort1(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    // 外层循环初始值为 false，没有发生交换
    let has_exchanged = false
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j ,j+1)
        has_exchanged = true
      }
    }
    // 内层循环结束判断一下是否发生了交换
    if (!has_exchanged) break
  }
  return arr
}

```

### 优化2

记录内层遍历最后一次发生交换的位置，下一次外层遍历只需要到这个位置就可以了。
那么外层遍历就不能用 for 了，因为每次遍历的结束位置可能会发生改变。

```js
function bubbleSort2(arr) {
  // 遍历结束位置的初始值为数组尾，并逐渐向数组头部逼近
  let high = arr.length - 1
  while (high > 0) {
    // 本次内层遍历发生交换的位置的初始值
    let position = 0
    for (let j = 0; j < high; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        // 如果发生了交换，更新 position
        position = j
      }
    }
    // 下次遍历只需要到 position 的位置即可
    high = position
  }
  return arr
}
```

### 优化3

双向遍历，每次循环能找到一个最大值和一个最小值。
前后各设置一个索引，向中间的未排序部分逼近。

```js
function bubbleSort3(arr) {
  let low = 0, high = arr.length - 1
  while (low < high) {
    // 正向遍历找最大
    for (let i = low; i <= high; i++) if (arr[i] > arr[i + 1]) swap(arr, i, i + 1)
    high--
    // 反向遍历找最小
    for (let j = high; j >= low; j--) if (arr[j] < arr[j - 1]) swap(arr, j, j - 1)
    low++
  }
  return arr
}
```

## 简单选择排序 (Simple Selection Sort)

每次遍历选择最小，但并不是倒着的冒泡排序，冒泡是比较相邻的两个元素。

算法步骤：

1. 设待排序数组r[1···n]，第一趟从r[1]开始，通过n-1次比较，从n个记录中选出最小的记录，记为r[k]，然后交换r[1]与r[k]。
2. 第二趟从r[2]开始，通过n-2此比较，再次选出最小然后与r[2]交换
3. 重复上面的操作，经过n-1趟后，排序完成

演示图：

![简单选择](https://user-gold-cdn.xitu.io/2019/3/29/169c903684fff481?imageslim)

```js
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let min_index = i
    // 遍历后面的部分，寻找更小值
    for (let j = i + 1; j < arr.length; j++) {
      // 如果有，更新min_index
      if (arr[j] < arr[min_index]) min_index = j
    }
    swap(arr, i, min_index)
  }
  return arr
}
```

## 堆排序 (Heap Sort)

## 直接插入排序 (Insertion Sort)

算法步骤：

1. 设待排序数组r[1···n]，r[1]是一个有序序列。
2. 循环n-1次，每次使用顺序查找法，查找r[i](i=2, ···, n)在已排好的序列r[1···i-1]中的插入位置，然后将r[i-1]插入表长为i-1的有序序列中，直到将r[n]插入一个表长为n-1的有序序列中结束。

## 折半插入排序

使用折半查找来代替上面的顺序查找，从而达到优化的目的。

算法步骤：

1. 设待排序数组r[1···n]，r[1]是一个有序序列。
2. 循环n-1次，每次使用折半查找法，查找r[i](i=2, ···, n)在已排好的序列r[1···i-1]中的插入位置，然后将r[i-1]插入表长为i-1的有序序列中，直到将r[n]插入一个表长为n-1的有序序列中结束。

## 希尔排序