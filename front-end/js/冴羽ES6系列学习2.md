# 冴羽ES6系列学习2

主要记录冴羽博客中ES6系列阅读后的关键点记录与总结

>[冴羽的博客](https://github.com/mqyqingfeng/Blog)
>
>ES规范[ECMAScript® 2019 Language Specification](http://www.ecma-international.org/ecma-262/)

## Babel 是如何编译 Class 的

ES6的 Class 可以看作一个语法糖，绝大部分功能ES5都可以实现。

+ 关于 constructor，ES5的构造函数相当于类的 constructor 方法。不过：类的内部所有定义的方法，都是不可枚举的
+ 实例属性，ES5中是写在构造函数内，并利用this，而ES6类中类似只不过是写在 constructor 内的。当然新的提案中也可以简写

  ```js
    class Person {
      state = {
        count: 0
      };
    }
  ```

+ 静态方法，ES6中通过static修饰的方法就是静态方法，而ES5中就是通过给构造函数添加属性的方式实现
+ 静态属性，ES6中通过static声明的属性就是静态属性，ES5中通过给构造函数添加属性实现
+ new调用，class是必须通过new调用的，而构造函数不必
+ getter 和 setter，ES5在原型中声明，而ES6在类声明中。

### 编译关于必须使用new调用

```js
// _classCallCheck 的作用是检查 Person 是否是通过 new 的方式调用
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var Person = function Person(name) {
    _classCallCheck(this, Person);
    this.name = name;
};
```

### 编译实例与静态属性

这个跟上面说的一样，写在 constructor 与写在外面的实例属性，都会通过this绑定到实例上，而静态属性是绑定到了构造函数上

```js
var Person = function Person(name) {
  _classCallCheck(this, Person);

  this.foo = 'foo';

  this.name = name;
};
Person.bar = 'bar';
```

### 编译静态方法实例方法以及getter/setter

Babel 生成了一个 _createClass 辅助函数，该函数传入三个参数，第一个是构造函数，在这个例子中也就是 Person，第二个是要添加到原型上的函数数组，第三个是要添加到构造函数本身的函数数组，也就是所有添加 static 关键字的函数。_createClass 中有生成了 defineProperties 辅助函数，使用 Object.defineProperty 方法添加属性。

```js
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
```

### ES6的extend

相比于ES5的寄生组合式继承，ES6的extend关键字，更清晰直观

```js
class Parent {
  constructor(name) {
    this.name = name;
  }
}
class Child extends Parent {
  constructor(name, age) {
    // super 关键字表示父类的构造函数，相当于 ES5 的 Parent.call(this)。
    // 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。
    // 这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。
    // 如果不调用 super 方法，子类就得不到 this 对象。
    super(name); // 调用父类的 constructor(name)
    this.age = age;
  }
}
var child1 = new Child('kevin', '18');
console.log(child1);
```

### 子类的 __proto__

