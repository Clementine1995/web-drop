# 冴羽ES6系列学习2

主要记录冴羽博客中ES6系列阅读后的关键点记录与总结

>[冴羽的博客](https://github.com/mqyqingfeng/Blog)
>
>ES规范[ECMAScript® 2019 Language Specification](http://www.ecma-international.org/ecma-262/)

## Babel 是如何编译 Class 的

ES6的 Class 可以看作一个语法糖，绝大部分功能ES5都可以实现。

+ 关于 constructor，ES5的构造函数相当于类的 constructor 方法。不过：类的内部所有定义的方法，都是不可枚举的
+ 实例属性，ES5中是写在构造函数内，并利用this，而ES6类中类似只不过是写在 constructor 内的。当然新的提案中也可以简写

  ```js
    class Person {
      state = {
        count: 0
      };
    }
  ```

+ 静态方法，ES6中通过static修饰的方法就是静态方法，而ES5中就是通过给构造函数添加属性的方式实现
+ 静态属性，ES6中通过static声明的属性就是静态属性，ES5中通过给构造函数添加属性实现
+ new调用，class是必须通过new调用的，而构造函数不必
+ getter 和 setter，ES5在原型中声明，而ES6在类声明中。

### 编译关于必须使用new调用

```js
// _classCallCheck 的作用是检查 Person 是否是通过 new 的方式调用
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var Person = function Person(name) {
    _classCallCheck(this, Person);
    this.name = name;
};
```

### 编译实例与静态属性

这个跟上面说的一样，写在 constructor 与写在外面的实例属性，都会通过this绑定到实例上，而静态属性是绑定到了构造函数上

```js
var Person = function Person(name) {
  _classCallCheck(this, Person);

  this.foo = 'foo';

  this.name = name;
};
Person.bar = 'bar';
```

### 编译静态方法实例方法以及getter/setter

Babel 生成了一个 _createClass 辅助函数，该函数传入三个参数，第一个是构造函数，在这个例子中也就是 Person，第二个是要添加到原型上的函数数组，第三个是要添加到构造函数本身的函数数组，也就是所有添加 static 关键字的函数。_createClass 中有生成了 defineProperties 辅助函数，使用 Object.defineProperty 方法添加属性。

```js
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
```

### ES6的extend

ES5中实现继承方法有很多，寄生组合式继承是其中比较好的一种办法。而相比于ES5的寄生组合式继承，ES6的extend关键字，更清晰直观

```js
class Parent {
  constructor(name) {
    this.name = name;
  }
}
class Child extends Parent {
  constructor(name, age) {
    // super 关键字表示父类的构造函数，相当于 ES5 的 Parent.call(this)。
    // 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。
    // 这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。
    // 如果不调用 super 方法，子类就得不到 this 对象。
    super(name); // 调用父类的 constructor(name)
    this.age = age;
  }
}
var child1 = new Child('kevin', '18');
console.log(child1);
```

### 子类的 __proto__

ES6中父类的静态方法是可以被子类继承的，因为 Class 作为构造函数的语法糖，同时有 prototype 属性和 __proto__ 属性，因此同时存在两条继承链。相比寄生组合式继承，ES6 的 class 多了一个 Object.setPrototypeOf(Child, Parent) 的步骤。

1. 子类的 __proto__ 属性，表示构造函数的继承，总是指向父类。
2. 子类 prototype 属性的 __proto__ 属性，表示方法的继承，总是指向父类的 prototype 属性。

注意：Object.setPrototypeOf(Child, Parent)是为了继承父类的静态属性，Child instanceof Parent 并不为真

### 继承目标

extends 关键字后面可以跟多种类型的值。下面例子中的A，只要是一个有 prototype 属性的函数，就能被 B 继承。由于函数都有 prototype 属性（除了 Function.prototype 函数），因此 A 可以是任意函数。

```js
class B extends A {
}
```

除了函数之外，A 的值还可以是 null，当 extend null 的时候：

```js
class A extends null {
}
console.log(A.__proto__ === Function.prototype); // true
console.log(A.prototype.__proto__ === undefined); // true
```

关键代码：

```js
function _inherits(subClass, superClass) {
  // extend 的继承目标必须是函数或者是 null
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  // 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  // 设置子类的 __proto__ 属性指向父类
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  // 对于 Parent.call(this) 的值，如果是 object 类型或者是 function 类型，就返回 Parent.call(this)
  // 如果是 null 或者基本类型的值或者是 undefined，都会返回 self 也就是子类的 this。
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

var Child = function(_Parent) {
  _inherits(Child, _Parent);

  function Child(name, age) {
    _classCallCheck(this, Child);

    // 调用父类的 constructor(name)
    var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name));

    _this.age = age;
    return _this;
  }
  return Child;
}(Parent);
```

具体步骤：

1. 首先执行 _inherits(Child, Parent)，建立 Child 和 Parent 的原型链关系，即 Object.setPrototypeOf(Child.prototype, Parent.prototype) 和 Object.setPrototypeOf(Child, Parent)。
2. 然后调用 Parent.call(this, name)，根据 Parent 构造函数的返回值类型确定子类构造函数 this 的初始值 _this。
3. 最终，根据子类构造函数，修改 _this 的值，然后返回该值。

## defineProperty 与 proxy

defineProperty用来详细的配置一个对象的某个属性的表现，比如是否可配置（configurable），是否可枚举（enumerable），还有数据描述符以及存储描述符（get,set），其中数据描述符还可以配置是否可写。而其中通过**存储描述符**拦截对象属性存取就是监听数据变化的关键。下面是一个简单的watch函数。

```js
(function(){
  var root = this;
  function watch(obj, name, func){
    var value = obj[name];

    Object.defineProperty(obj, name, {
      get: function() {
        return value;
      },
      set: function(newValue) {
        value = newValue;
        func(value)
      }
    });
    if (value) obj[name] = value
  }
  this.watch = watch;
})()
```

而 Proxy 可以重定义更多的行为
