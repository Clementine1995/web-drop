# 重启面试点整理

## JS 部分

- 手写 Promise
  - 为啥要有 Promise？防止回调地狱
  - 注意的点：then()/catch()需要传入一个函数，如果传入非函数会发生值穿透；在 then 中函数里 return 的值会被包裹 Promise.resolve(val)，如果没有 return，val 就是 undefined；finally()的回调函数不接受任何的参数，它最终返回的默认会是一个上一次的 Promise 对象值，不过如果抛出的是一个异常则返回异常的 Promise 对象。
- 手写防抖节流以及优化
  - 防抖关键就是定时器只要存在就清空掉
  - 节流定时器方法关键是只要定时器存在，就不执行，时间戳版就是判断两次触发的时间差是否小于设定时间
- 手写 call,apply,bind（也就是改变 this 指向）
  - 通过将方法绑定到指定对象上执行再删除掉的办法来写
- 实现一个 Eventbus，也就是订阅者发布者模式
  - 最关键的是 emit 方法跟 on 方法，on 方法存储事件名称与对应的函数，emit 执行对应的函数
- reduce，递归数组，实现 map，flat，传参控制数组层数，以及其他 reduce 的应用
  - 实现 map，就是在 reduce 中把每一项用 cb 处理后放到数组里返回
  - 实现 flat，递归的方法，如果是数组再次组合
- 深拷贝与浅拷贝，以及手写
  - 数组浅拷贝：slice，concat 方法，展开运算符，对于对象浅拷贝可以用 Object.assign
  - 深拷贝主要是利用递归的办法，也有 JSON.parse(JSON.stringify(obj))的办法，不过这个办法对函数无效，递归中注意循环引用的问题，可以采取 weakmap 来记录对象
- setTimeout 实现 setInterval
  - 首先声明一个方法，其中调用回调函数，然后函数中使用 setTimeout 调用自身，初始的时候调用一次这个函数就可以了
- 实现一个 Sleep 效果，利用 Promise
- 数组去重的方法？（这个有整理）利用 filter,includes 等数组方法，或者 Set
  - 利用 indexOf，创建一个临时数组，如果 indexOf 为-1 则 push 进
  - 利用 filter，过滤数组中某个元素第一次出现的下标跟当前下标不同的
  - object 键值对
  - Set 去重
- 创建对象的多种方法
  - 工厂模式，通过 new Object 出的实例来扩展属性，调用时不使用 new,创建的对象无法识别。
  - 构造函数模式，缺点就是如果实例中有函数，每次创建实例都会新创建一次其中函数
  - 原型模式，所有的属性都存放于原型之上，属性共享且无法传递初始化参数
  - 组合模式，共享属性放至原型，私有属性通过构造函数设置
    - 动态组合模式，将设置原型共有属性逻辑，放至构造函数内，如果有没有该属性，向原型设置，否则不处理，注意这时不能用对象字面量去覆盖原型
  - 寄生构造模式，其实就是工厂模式通过 new 来调用
    - 稳妥构造函数模式，其中不引用 this，不过创建的对象也不能识别
- 继承的几种情况
  - 原型链继承：将子类的 prototype 设置为父类的实例，缺点就是父类中的引用类型属性会被共享，并且不能向父级传参
  - 经典继承（借用构造函数）：在自己中通过 call 调用父级构造方法，从而解决共享与传参问题，缺点就是方法都要在构造函数内部定义，每创建一个实例都要创建一次方法
  - 组合继承：在经典继承基础上，将共享方法移到父类的原型上，将子类的 prototype 设置为父类的实例，子类原型构造器属性指回子类构造方法，缺点是会调用两次父类构造方法
  - 原型式继承：与原型链继承类似，直接将目标对象作为子类的原型，也存在共享问题
  - 寄生式继承：在原型式继承基础上，利用 Object.create()方法，创建一个对象，然后在增强它，缺点就是每创建一次创建一次内部方法（如果有的话）
  - 寄生组合式继承：在组合继承基础上，为了解决父级构造函数调用两次的问题，引入中间构造函数，将其原型设置为父级原型对象，再将子级原型对象设置为中间构造函数的实例。
- 生成器和迭代器
  - 迭代器其实就是一个具有 next 方法的对象，每次调用 next 方法都会返回一个结果对象，结果对象有两个属性，一个是 value 表示当前值，一个是 done 表示迭代是否结束
  - 生成器是一个可以返回迭代器的函数，通过 function 关键字后面加一个\*来表示，其中会用到 yield 来表示
- forEach 与 map 的区别，能否改变自身，能否退出循环
  - forEach()返回值是 undefined，不可以链式调用。map()返回一个新数组，原数组不会改变。没有办法终止或者跳出 forEach()/map 循环，除非抛出异常，所以有了 ES6 的 forof 循环
- 详细解释一下 this，谈谈理解
  - 对于函数而言，指向最后调用函数的那个对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用；对于全局而言，this 指向 window。而在箭头函数中，this 指向定义时的上下文，普通函数，this 指向执行时上下文。
  - this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。
  - 全局作用于下的 this 就是 window 对象（浏览器中）
  - 函数执行上下文中的 this 就有很多情况了，可以通过 call,apply,bind 来改变 this 指向；也可以通过对象调用来改变 this 指向；可以通过构造函数 this 指向新的对象实例这一特点来改变 this 指向
  - 注意的是嵌套函数中的 this 不会从外层函数中继承，可以通过缓存 this 或者箭头函数来解决
- 说说执行上下文与执行栈
  - 执行上下文类型：全局执行上下文，函数执行上下文，Eval 函数执行上下文
  - 执行栈，也就是在其它编程语言中所说的 “调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。
- JS 为什么是单线程，与异步有什么区别
  - JS 是单线程，为了安全稳妥，如果是多线程，那么就会有同时操作同一个 DOM 的情况，这个时候就会出现问题，并且 JS 执行速度很快。但是还是需要异步，就是为了在一些场景需要等待时，不会阻塞继续执行，保证页面不会卡死。
- map 总是返回值吗，以及其他数组方法的返回值
  - map 会返回新数组，即使内部不 return，会默认 return undefined
- 箭头函数特点，以及与匿名函数的区别
  - 箭头函数的 this 由最近一层非箭头函数的 this 决定
  - 箭头函数没有自己 arguments
  - 箭头函数不能通过 new 来调用
  - 箭头函数没有原型，没有 new.target，没有 super
- 函数式编程：高阶函数，函数柯里化，函数组合...
  - 柯里化：把接受多个参数的函数转变为单一参数的函数，并且返回接受余下的参数且返回结果的新函数。
  - 柯里化好处：参数复用，提前确认，延迟执行
- 原型与原型链
  - 原型是一个对象，每个函数都有一个 prototype（除箭头函数）属性，这个属性的指向就是函数的原型对象，也是通过函数创建对象生成实例的原型，实例可以从原型上继承一些属性，不同实例之间也可以共享它们。
  - constructor 是啥？实例的属性 construction 指向构造函数，同时原型对象的 construction 也会指向构造函数
  - `__proto__`是啥？每个实例对象都会有的属性，指向它的原型对象，Object.prototype 的 `__proto__`指向 null
  - Object 与 Function 的原型指向？
  - 原型链其实就是访问对象某个属性时，这个属性的查找顺序。
- EventLoop（事件循环）
  - Eventloop 即事件循环，是浏览器或者 node 一种解决 JS 单线程运行不会阻塞的一种机制，也就是异步原理。JavaScript 从 script 开始读取，然后不断循环，从 “任务队列” 中读取执行事件的过程，就是 事件循环（Event Loop），为了协调事件、用户交互、脚本、渲染、网络等。
  - JS 是一个单线程的语言，安全稳妥，但为什么需要异步呢，当涉及某些需要等待的操作时，为了让程序能继续运行。
  - 宏任务：script,setTimeout,setInterval,setImmediate,I/O,UI rendering
  - 微任务：MutationObserver,Promise.then()/catch(),V8 垃圾回收机制,Node 独有的 process.nextTick,以 Promise 为基础的技术
  - EventLoop 执行过程：
    1. 一开始整个脚本 script 作为一个宏任务执行
    2. 执行过程中，同步代码 直接执行，宏任务 进入宏任务队列，微任务 进入微任务队列。
    3. 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完毕。
    4. 执行浏览器 UI 线程的渲染工作。
    5. 检查是否有 Web Worker 任务，有则执行。
    6. 执行完本轮的宏任务，回到步骤 2，依次循环，直到宏任务和微任务队列为空。
  - requestAnimationFrame，可以解决动画卡顿的问题，具体说明在下面
  - 浏览器中的 Event Loop 与 node 中是不同的，浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行；在 node 中，宏任务又分为不同的类型，有 timers，check，close callback,poll 类型，每执行完一种宏任务就会清空微任务，在执行下一种宏任务再清空微任务，一直循环
- 说说 Web Worker
  - HTML5 的新规范中，实现了 Web Worker 来引入 JavaScript 的 “多线程” 技术，它的能力让我们可以在页面主运行的 JavaScript 线程中加载运行另外单独的一个或者多个 JavaScript 线程。但是 JS 本质还是单线程的，Web Worker 只是浏览器（宿主环境）提供的一个 API
- new 过程干了什么，手写一个 new
  - 创建一个新对象 const obj = {}
  - 将这个新对象的 `__proto__` 指向构造函数的原型对象，`obj.__proto__ = Object.create(func.prototype)`，通过 setPrototypeOf 也可以原型
  - 通过 apply 绑定 this 到新对象并执行构造函数 `func.apply(obj, args)`
  - 返回这个 obj，当然如果构造函数本身会返回内容则还需额外判断
- 讲讲闭包
  - 调用一个函数其中返回一个内部函数，内部函数中使用外部函数的变量，使这些变量能存在于内存中，这些变量的集合就是闭包
  - 闭包的好处：变量私有，外部无法直接改变；实现函数柯里化，当然坏处就是内存消耗以及性能问题
  - 所有的函数在“诞生”时都会“记住”创建它们的词法环境。所有函数都有名为 `[[Environment]]` 的隐藏属性，该属性保存了对创建该函数的词法环境的引用，这也使得闭包成为可能
- ES6 新东西以及后续 ES 版本的新东西了解
  - let/const，symbol
  - Promise,async/await,Reflect
  - 箭头函数
  - 生成器/迭代器
  - 类
  - 解构
  - set,map
  - 模块
  - 新的运算符 ?? ?.
- null 与 undefined 的区别？
  - null：Number(null)得到 0，作为对象原型链的终点（`Object.prototype.__proto__ === null`）
  - undefined：Number(undefined)得到 NaN；变量声明没被赋值，等于 undefined；调用函数，对应参数没提供也是 undefined；函数没有返回值默认返回 undefined；对象某个属性值没赋值，也是 undefined；另外判断的时候，通常用 void 0 来代替 undefined 更加准确。
- 说明一下事件流，addEventListener 函数作用，是否所有的事件都有冒泡阶段？
  - 事件流：事件捕获阶段，处于目标阶段，事件冒泡阶段
  - addEventListener 方法将指定的监听器注册到 EventTarget（可以是文档上的元素 Element、Document 和 Window 或者任何其他支持事件的对象（例如 XMLHttpRequest）） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。
  - addEventListener 函数可以接受四个参数，第一个表示事件类型，第二个参数为一个函数，第三个参数一个指定有关 listener 属性的可选参数对象，第四个参数表示在 DOM 树中，注册了 listener 的元素，是否要先于它下面的 EventTarget 调用该 listener，默认 false
  - addEventListener 的第三个参数涉及到冒泡和捕获，为 true 时是捕获，为 false 时是冒泡。
  - 阻止冒泡的方法：event.stopPropagation()，也就是事件不会再往外层传递
  - onmouseover 和 onmouseenter 区别：这两者都是移入的时候触发，但是 onmouseover 会触发多次，而 onmouseenter 只在进去的时候才触发。
  - 并不是所有的事件都有冒泡，例如：onblur，onfocus，onmouseenter，onmouseleave
- typeof 和 instanceof 的区别
  - typeof 对某个变量类型的检测，基本类型除了 null 之外，都能正常地显示为对应的类型，引用类型除了函数会显示为 function，其他都显示为 object。
  - instanceof 主要用于检测某个构造函数的原型对象在不在某个对象的原型链上，主要是根据原型进行比较。
  - 为了更精确的进行变量类型判断，可以是用 Object.prototype.toString.call()
- 如何判断变量类型？
  - typeof：能区分的有 number，string，boolean，undefined，function，bigint，symbol
  - instanceof：能判断的有：Array，Function，Date，RegExp，Error
  - constructor：除了 undefined 和 null，其他类型基本可以通过 constructor 判断。
  - Object.prototype.toString.call
- JS 如何获取元素宽高，有哪些属性？
  - clientHeight/clientWidth
  - offsetHeight/offsetWidth
  - scrollHeight/scrollWidth
  - clientTop,scrollTop
- JS 如何实现拖拽
  - 通过 mousedown、mousemove、mouseup 方法实现
  - 通过 HTML5 的 Drag 和 Drop 实现
- 说说渐进式网络应用（PWA）
- 说说规范化：CommonJS,AMD,CMD,ES6 Modules 之间的区别？（有整理）
  - CMD 推崇依赖就近，延迟执行，异步加载
  - AMD 推崇依赖前置，提前执行，异步加载
  - 服务器端比如 node，采用的则是 CommonJS 规范。它与 CMD 相似，都是在 require 的时候才去加载模块文件，加载完再接着执行，注意是同步加载。
  - ES6 Modules 是编译时输出接口，输出的是值的引用
- babel 编译原理？
  - babylon 将 ES6/ES7 代码解析成 AST
  - babel-traverse 对 AST 进行遍历转译，得到新的 AST
  - 新 AST 通过 babel-generator 转换成 ES5
- 常见的数组 API 有哪些？（这个有整理）
  - Array.of()跟 Array.from()，from 方法可以支持类数组，of 方法传入参数都转换为数组元素，跟 Array 构造函数不同，Array 构造函数如果传入一个数字，那么这个数字就是数组的长度
  - find()，findIndex()
  - some(),every(),includes()
  - map,filter,reduce
- 数字千分化？
  - 利用正则或者 toLocaleString('en-US')
- 说说 requestAnimationFrame？
  - requestAnimationFrame 类似于 setTimeout，但是它可以当成一个微任务来看，是在微任务队列执行完毕后，执行 UI 渲染前，调用的一个方法，常常用来优化动画。
  - 为什么不用 setTimeout 来控制动画呢？setTimeout 的执行时机是不确定的，它属于宏任务队列，只有当主线程上任务执行完毕，才会调用队列中的任务判断是否开始执行，而且不同设备的屏幕刷新率不同，setTimeout 只能以固定的一个时间间隔刷新，而在执行完微任务之后，会执行浏览器 UI 线程的渲染工作，requestAnimationFrame 就在这里执行，不会等宏任务的排队，从而改善卡顿问题
- 说一下函数执行过程，ES6 之前与之后的变化。
  - 函数执行上下文包括 this 指向，变量环境，词法环境
  - 简单来说词法环境是一种持有标识符—变量映射的结构。词法环境分类为：全局环境，模块环境，函数环境
  - 词法环境构成为：外部环境的引用，环境记录器
    - 外部环境的引用：可以访问其父级词法环境（即作用域）
    - 环境记录器：存储变量和函数声明的实际位置，在全局环境中，环境记录器是对象环境记录器。在函数环境中，环境记录器是声明式环境记录器。
    - 对于环境记录器又分为声明式环境记录器，对象式环境记录器，全局式环境记录器
    - 声明式环境记录器：范围包含函数定义，变量声明，try...catch 等，此类型对应其范围内包含的声明定义的标识符集，对于函数环境来说，还有一个 arguments 对象以及传递给函数的参数的 length。
    - 对象式环境记录器：用来定义出现在全局上下文中的变量和函数的关系。此外也是用于记录标识符与变量的映射，会为对象式环境记录中所有的标识符绑定到绑定对象的同名属性上，但是它只记录 var 声明的标识符，例如 var number=1000;也能够通过 window.number 形式获取到 number 的值。
  - 变量环境用来存放 var 变量绑定
- JS 中的变量声明？变量提升与函数提升？临时死区？
  - var、let、const 都可以用于变量声明。var 可以重复声明，作用域为全局作用域和函数作用域，并且会进行预解析；let 在同一作用域中不能重复声明，作用域为全局作用域和块级作用域，不会进行预解析，let 存在临时死区，全局声明的 let 不会绑定到 window 对象上；const 则是 let 有的它也有，但是初始化时必须赋值，并且赋值后不能再改动
  - 临时死区就是在使用 let/const 声明变量之前，该变量都是不可用的，并且只要块级作用域中存在 let/const 指令，它所声明的变量就绑定这个区域，不再受外部影响。
  - 变量提升和函数提升：通过 var 定义的变量，在声明之前可以访问，会打印 undefined，函数声明则会提到最前面
- JS 中作用域？
  - 函数作用域：函数内部的变量只能通过函数内部访问
  - 块级作用域：变量在离开定义的块级代码后立即被回收，存在暂时性死区的特性。ES6 中通过{}界定
  - 全局作用域

## CSS 部分

- 动画
  - transform，变换，可以对元素进行旋转，放大缩小，位移，倾斜，支持 2d 与 3d 转换
  - animation，动画，需要配合 keyframe 关键帧来实现
  - transition，过渡，可以设置某个属性发生变化时执行（需要事件触发），是一次性的，并且只是开始与结束状态的过度，不能定义中间状态
- 伪元素选择器，伪类选择器有哪些，有什么好处
  - :before，:after，好处就是可以通过 content 设置内容，当作一个元素（默认 inline）来使用，但是又不占标签，可以清除浮动，作为小图标或者背景之类
  - first 系列：:first-line，:first-letter，:first-child，:first-type-of，同理还有 last 系列
  - :selection
- 文档流布局（几个定位）
  - relative：相对定位，参照自己本身，并不脱离文档流
  - absoulue：绝对定位，脱离文档流，并且是以最近一个不是 static 的父元素定位
  - fixed：相对于浏览器窗口定位，脱离文档流
  - static：默认值
  - sticky：粘性布局，也就是吸附效果，不过必须设置阈值其中一个，并且父元素 overflow 需要是 visible，父元素高度还需要高于设置了 sticky 的元素
- 三栏布局浮动，圣杯布局
  - 主要是通过设置 margin-left 负值与 float 来实现，现在可以用 flex 代替
- 移动端适配问题
  - 有 flexable.js，通过设置 html 的 font-size 配合 rem 单位来实现自适应
  - px to vw 方法，利用 postcss 插件
  - rem + vw 以 375 设计稿为例：font-size: 26.6666666666666667vw;
  - px to vw 转换 rem
- 新的 CSS 属性了解哪些，CSS3 有哪些新东西，与 xyz 轴相关的有哪些
  - 动画，其中 transform 一些方式中有与 xyz 轴相关，perspective 透视
  - 新增了一些选择器 first/last 系列
  - 阴影 box-shadow
  - 边框圆角 border-radius
  - background 相关，background-clip,background-size,多张背景图
  - 文字，word-break，text-overflow，文字阴影 text-shadow
  - rgba
  - 渐变，线性渐变，锥形渐变，径向渐变
  - 滤镜 filter
  - flex，grid，多列布局
  - css 变量
  - 长度单位 rem vw vh
  - object-fit
  - will-change
  - overscroll-behavior,scroll-behavior,scroll-snap-type
- 选择器有哪些，比如选择某一个之后的用什么
  - ~选择器：兄弟选择器，选择某个元素后的所有兄弟元素
  - +选择器：相邻兄弟选择器，可以选择紧跟在另一个元素后的元素，并且两者有相同父元素
  - 后代选择器，空格就行
  - 子元素选择器>，必须是子元素
  - id 选择器#，类选择器:，属性选择器[]
- 格式化上下文，IFC,BFC,IFC,GFC,FFC
  - 格式化上下文，其实就是页面中的一块渲染区域，其中有自己的渲染规则，决定子元素如何定位，以及它和其它元素之间的关系
  - IFC：行内级格式化上下文，只有在一个块级元素中仅包含内联级别元素时才会生成。布局上内部的盒子会在水平上一个接一个放置，高度又行高决定，水平方向渲染由 text-align 决定，垂直方向由 vertical-align 决定，而当其中某个行内元素宽度超过行盒的时候会折行，如果不支持折行（比如 white-space 等控制），就会溢出
  - BFC：块级格式化上下文，里面的元素在布局上不会影响到外面的元素，比较常见的形成条件有：绝对定位/fixed 定位，浮动，根元素，overflow 不为 visible 的，flex，grid 布局，display 的值为 inline-block 等，它有一些布局规则：垂直方向 margin 会发生重叠（可以通过生成新的 BFC 来解决），计算 BFC 的高度时，浮动元素也参与计算（可以解决浮动坍塌），内部的 Box 会在垂直方向，一个接一个地放置；BFC 的区域不会与 float box 重叠。
  - FFC：display 为 flex 或者 inline-flex 的情况，形成弹性容器，但是其与块布局不同，其中 float，vertical-align 不会生效，一些伪类选择器也不会生效
- 居中问题
  - 水平居中
    - 对于行内元素来说，text-align:center 就可以
    - 对于宽度确定的块级元素，margin:0 auto;
    - 或者 width:fit-content;margin:0 auto;
    - flex 布局 justify-content: center;
    - grid 布局也可
    - 绝对定位 left:50%;transform:translate(-50%,0)
  - 垂直居中
    - 对于单行文本内容，可以利用行高等于父元素高度
    - 父元素 display:table，子元素 display:table-cell;vertical-align: middle;
    - flex 布局 align-items: center;
    - 绝对定位 top:50%;transform:translate(0,-50%)，如果高度确定也可以，margin-top:-0.5\*高度
    - 利用伪元素，子元素伪元素都设置为 display:inline-block;vertical-align: middle;伪元素高度 100%
  - 水平垂直居中，就是将上面两种结合

## HTML 部分

- HTML 基本结构，第一行是干嘛的，去掉第一行会怎么样
  - <!DOCTYPE> 声明不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本；不加的话浏览器会按照自己的方式解析，可能会有怪异情况出现
- link 与 import 区别
  - 相同点：两者都可以用来加载 css
  - 不同点：
    - link 属于 XHTML 标签，而@import 完全是 css 提供的一种方式，link 标签除了可以加载 css 外，还可以通过 rel 属性来做其他的事情，比如链接一个外部的 icon，规定一些作者和版权相关的信息，prefetch/preload 来预加载一些资源等等，而 import 只能加载 css
    - 当一个页面加载的时候，link 引用的 CSS 会同时被加载，而@import 引用的 CSS 会等到页面全部被下载完再加载。
    - 兼容性的差别。由于@import 是 CSS2.1 提出的所以老的浏览器不支持
    - 使用 dom 控制样式时的差别。当时用 JavaScript 控制 dom 去改变样式的时候，只能使用 link 标签
    - @import 可以在 css 中再次引入其他样式表
- href 与 src
  - 请求资源类型不同：href 用于建立这个标签与外部资源之间的关系。在请求 src 资源时会将其指向的资源下载并应用到文档中，替换效果
  - src 一般是 script、img 、iframe 中用，href 一般是 link、a
  - 浏览器解析方式不同：当浏览器解析到 src，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，而 link 则是同步执行，比如加载样式表，这与 html 解析是同时的
- 一些常用的 DOM API，比如获取元素（getElementById,querySelector），创建元素，添加元素，删除元素等等
  - createElement()，appendChild()，removeChild()
- 什么是 SEO
  - Search Engine Optimization 翻译是：搜索引擎优化，网站进行合理的 SEO 优化是你的网站在搜索引擎的排名提高，从而利用搜索引擎给自己带来客户
  - 合理的 title 、 description 、 keywords ：搜索对着三项的权重逐个减小
    - title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同前面 title 有所不同
    - description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同
    - keywords 列举出重要关键词即可
  - 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页
  - 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取⻓度有限制，保证重要内容⼀定会被抓取
  - 重要内容不要用 js 输出：爬虫不会执行 js 获取内容
  - 少用 iframe ：搜索引擎不会抓取 iframe 中的内容

## 框架部分

### Vue

- 生命周期：vue3 中 destory 相关被换成了 mount，组合式 api 中只需要在前面加上 on 就可以，并且 setup 函数代替了 create 和 beforeCreate
  - beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。插件内部的 instanll 方法通过 Vue.use 方法安装时一般会选在 beforeCreate 这个钩子内执行，vue-router 和 vuex 就是这么干的
  - create：完成数据观测，属性和方法的运算，watch/event 回调，但是还没有挂载，$el还不可用，因此也访问不到$ref
  - beforeMount：挂载之前调用，相关的 render 函数首次被调用，实例已经完成模板编译，把 data 里的数据和模板生成 html，此时还没有挂载到 html 页面上
  - mounted：在 el 被新创建的 vm.$el 替换，并挂载之后调用，此时已经可以拿到具体 dom
  - beforeUpdate：数据更新时调用，发生在虚拟 dom 打 patch 之前，可以在更新前访问先有的 dom
  - updated：在由于数据更改导致的虚拟 dom 重新渲染和打补丁之后调用，调用时 dom 已经更新为最新，应该避免在这时再更改状态
  - beforeUnmount：在卸载组件前调用，实例还是可以正常访问的
  - unmounted：卸载组件实例之后调用，调用时，组件所有的指令都被解除绑定，事件侦听器都被移除，子组件实例也被卸载
- vue 父子组件生命周期钩子执行顺序
  - 父组件 beforeCreate create beforeMonunt 然后转进子组件 beforeCreate create beforeMount mounted 再转回挂在父组件 mounted
- vuex 跟 localStorage 区别？
  - 最重要区别，vuex 存在内存中，localStorage 以文件的形式存在本地，且只能存储字符串类型数据；这也意味着刷新页面 vuex 中存储数据会丢失，而 localStorage 不会
  - localStorage 是本地存储，将数据存储到浏览器，一般在跨页面传递数据时使用；vuex 是方便状态管理，主要在组件之间传值，而且可以做到数据响应式
- MVVM 是什么？
  - Model-View-ViewModel，ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model。
- 什么是双向绑定？原理是什么
  - 视图的变化会更新到模型层，而模型层更新会同步到视图层
  - Vue 中是使用数据劫持+发布订阅模式来实现的，vue2 中数据劫持使用 Object.defineProperty()，vue3 中使用了 Proxy。
  - Object.defineProperty()劫持各属性的 getter/setter，并在数据发生变化时通知订阅者，触发相应的监听回调。响应式主要分为三个模块：Watcher，Observer，Compiler。
    - Observer：主要负责对数据对象的所有属性进行监听，监听到数据变化后通知订阅者
    - Compiler：扫描模板，解析指令并绑定指定事件
    - Watcher：关联 Observer 和 Compiler，能够订阅到属性变化的通知，执行指令绑定的相应操作，更新视图
  - vue3 使用 Proxy 的优点
    - Object.defineProperty 不能监听数组，只能监听属性，而不是整个对象，需要在初始化时遍历整个对象属性，监听属性时只能监听属性的变化，而不能监听属性删减
    - Proxy 可以监听数组，监听整个对象而不是属性，拦截方法很多，返回新对象而不是直接修改原对象，在访问到某个属性时如果是对象才代理，性能上好一些
    - Proxy 缺点就是兼容性
- watch，computed 区别
  - computed 支持缓存，也就是在依赖项发生变化时才会重新求值，watch 不行，是要数据发生变化就会调用相关回调
  - computed 不支持异步，watch 支持
  - 如果一个属性是有其他属性计算而来，一般采用计算属性；而当有异步操作时会选择 watch
  - watch 支持定制，比如 immediate 属性，让组件加载立即触发回调，还有 deep 属性，深度监听
  - computed 支持 get/set
- 路由钩子在 Vue 生命周期中的体现？
  - 全局路由钩子 beforeEach 可用于判断登录，afterEach 可以让页面滚动到顶部
  - 触发进入其他路由-》离开路由的 beforeRouteLeave->全局 beforeEach->beforeEnter->解析异步路由组件-》beforeRouteEnter->导航确认->afterEach->组件生命周期钩子-》挂载后会执行 beforeRouteEnter 的 next 回调
- router 与 route
  - route 对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query 对象等。
  - router 对象是全局路由的实例，是 router 构造方法的实例。上面有很多实例方法 push,go,replace 等等
- v-指令，自定义指令如何使用
  - 可以全局注册也可以局部注册，有几个重要的钩子函数 created，beforeMount,mounted,beforeUpdate,updated,beforeUnmount,unmounted 跟 vue2 版本有区别
  - created：在绑定元素的 attribute 或事件监听器被应用之前调用。
  - beforeMount(bind)：当指令第一次绑定到元素并且在挂载父组件之前调用。
  - mounted：在绑定元素的父组件被挂载后调用。
  - 使用场景：自定义指令是用来操作 DOM 的，可以当作一种有效的扩展和补充
- mixins 跟 extends
  - 都是用于合并扩展组件
  - mixins 接收一个混入对象的数组，而 extends 是便于扩展单组件
- 双向绑定为什么要对数组进行特别处理
  - vue 官方当通过索引直接设置数组项时，并不能响应式检测，其实 Object.defineProperty 可以监测数组索引变化的，作者因为考虑到性能问题，放弃了这个做法，改为拦截了数组的原型，重写了 7 个能改变自身的数组方法，这些方法内部还是调用了原生的数组方法，只不过是在拦截中触发了更新，而不是 setter
- 3 版本与 2 版本区别，与 react hook 的区别
  - 项目结构优化，内部解耦更好维护，monorepo 管理，便于 tree-shaking
  - 使用了 Proxy 代替了 defineProperty
  - 添加了组合式 api，便于组件复用
  - 优化插槽等等
  - 还做了很多内部优化，提升性能
  - 更好的 ts 支持
  - vite 的使用
- 动态组件
  - 利用 component 这个内置组件，其 is 属性就可以指定哪个组件被渲染
- sync 修饰符
  - vue3 中建议用 v-model 代替，并且自定义 v-model 支持绑定多个
  - 某些情况下需要对一个 prop 进行双向绑定，但是子组件不能修改 prop，所以使用 emit 的办法来修改，sync 修饰符就是 v-bind:xxx="yyy" v-on:update:xxx 的语法糖
- vue-router 的原理
  - vue-router 主要用到的是 hash 跟 history 模式
  - hash 模式基于浏览器 history api，使用 window.addEventListener('hashchange', cb)监听 hash 的变化，将页面加载到对应的 dom 位置
  - history 模式基于浏览器 history api，使用 window.onpopstate 对浏览器地址进行监听，对 pushState()，replaceState()进行封装，对浏览器历史栈进行修改，从而实现 url 的跳转，当然需要后端配合，否则会请求不到资源
- nextTick 实现原理
  - 在下次 DOM 更新循环结束之后执行延迟回调。在实现上优先使用 Promise，如果不支持就用 MutationObserver，在不支持使用 setImmediate，最后是 setTimeout
  - vue 的 dom 更新是异步更新，如果是同步更新，多次对同一个属性赋值，就会频发触发渲染，性能不好。大致思路就是当数据变更时，会触发 watcher 的 update 但是不让它立即执行，而是存在一个更新队列中，并且调用 nextTick 为它创建一个微任务来保存这些的更新，这个微任务在一次渲染中只会创建一次，同时自定义的 nextTick 回调也会加入到队列中，等主进程结束后，多次更新一起执行。
- render 函数
  - 绝大数情况下可以使用 template 来创建 html，但有时候需要 js 来实现，就需要用到 render 函数，其实就是 createElement()函数，它可以接受多个参数，第一个参数指定要生成的节点标签名称，也可以是已有组件，第二个参数指定标签属性，第三个参数指定其 children
- vue 的组件间通信
  - 父级-》子级通过 prop；子级向父级通过 emit 传递信息
  - 兄弟间可以使用 eventbus
  - $parent和$children，$children已经被移除，代替是$refs
  - provide 和 inject（不建议使用）
  - $attrs和$listeners，$listeners已经被移除，其实是成为了$attrs 的一部分，直接 bind 即可
- 组件渲染前的初始化过程

- 计算属性如何实现，watch 如何实现

- 响应式内部的实现原理（3 版本）
  - 利用 Proxy 拦截，在 get 陷阱里收集依赖，在 set 陷阱里触发相应回调，effect 副作用函数，用来创建修改数据时可自动执行的函数，链接了 get 跟 set
- keep-alive
  - keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它
  - 过程首先获取其包裹子组件的实例对象，来获取组建的组件名 name，根据 name 去匹配 include 和 exclude 来判断是否需要缓存，不需要直接返回 vnode，需要缓存的话先判断其是否在缓存数组里，如果存在，则将它原来位置上的 key 给移除，同时将这个组建的 key 放到数组最后，如果不存在将组件 key 放入数组，然后判断当前 key 数组是否超过 max 所设置范围，超过那么削减未使用时间最长的一个组件的 key 值，最后将这个组件 keepAlive 设置为 true
- 单页面应用跟多页面应用区别
  - 单页面应用只有一个主页面的应用，也就是一个 index.html，页面跳转其实是组件间的切换
  - 多页面应用，多个独立页面的应用，每个页面必须重新加载 css js 等资源，页面跳转整页资源都需要刷新
  - 刷新方式：spa 局部刷新组件替换，mpa 整页刷新
  - 路由模式：spa 使用 hash 或者 history，mpa 链接跳转
  - 用户体验：spa 页面切换较快，当然首页资源过多的话也需要优化，mpa 页面切换加载较慢
  - 转场动画：spa 容易实现，mpa 无法实现
  - 数据传递：spa 方法很多，路由传参，vuex 等，mpa 依赖 url，本地存储
  - seo：需要服务端渲染，mpa 比较容易
  - 开发成本：spa 相对容易
  - 资源：spa 共用资源加载一次，mpa 都需要重新加载
- 说一下 vuex 的内容
  - vue 组件中会触发 dispatch 一些动作或事件，动作或者事件叫做 Actions，然后把改变提交 commit 到 mutations 中，mutations 中改变 state 中的数据，state 数据改变触发重新渲染，完成一个流程
- v-model
  - v-model 实际上是 v-bind:value="message"和 v-on:input="message=$event.target.value"的语法糖，自定义v-model中默认用名为value的prop和input事件，如果要改需要通过在子组件model选项改（vue3中有改动），其实也是父子组件通信的语法糖，利用props和$emit
- 为什么 vue 的 data 必须是函数
  - 组件是可以复用的，如果不是函数而是对象的话，共用同一个对象会互相干扰，vue3 中 data 已经不允许为对象了
- 路由传参，动态路由，路由跳转方式
  - 地址栏传参（query 方式），通过$route.query获取；params方式，通过$route.params 获取，类似/user/:id 的形式
  - 路由跳转方式：`<router-link to=''>`，router.push
- 说说虚拟 dom，优缺点
  - 虚拟 DOM 就是由普通的 JS 对象来描述 DOM 对象，并不是真实的 DOM，但是创建虚拟 DOM 的开销要比真实 DOM 小很多。
  - 优点：可以借助不同的 renderer 来实现跨平台，通过操作 js 对象，而不依赖真实平台；不需要立即更新 dom，通过 diff 算法有效的只更新变动的部分，降低了部分渲染开销；省去了手动操作 dom，也提高了开发效率
  - 缺点：虚拟 dom 是比真实 dom 慢的，毕竟多包装了一层
- 说说 vue 跟 react 的理解，它们的区别
  - 相似处：都将注意力集中在核心库，其他功能交给别的相关库；都使用了虚拟 dom；都有 prop 的概念；都鼓励组件化
  - 不同：vue 支持双向绑定，react 一直是单向数据流；react 推荐 jsx 语法来书写，vue 则是常规 html 模板；react 实现扩展使用高阶组件，本身就是函数，方便扩展，vue 则是 mixins；react 状态更新后，子组件都会重新渲染，不过这个也是可以控制的；vue 则是默认优化

### webpack

- webpack 的作用是什么？
  - 模块打包，将不同模块的文件整合到一起，确保它们引用正确，执行有序
  - 编译兼容，通过 loader，可以帮助我们对代码做 polyfill，还可以编译转换.scss,.less,.vue,.jsx 等浏览器无法识别的格式文件，让开发时使用新的语法和特性
  - 能力扩展，通过 plugins，让我们在上面两个基础上，可以进一步实现按需加载，代码压缩等功能
- loader 与 plugin 的区别与实现原理
  - webpack 最终打包出来的是 js 代码，实际上 webpack 内部也是只能处理 js 模块代码，因此当解析中遇到非 js 文件，就需要对其进行转换，才能继续执行打包任务，转换就需要 loader，loader 支持以数组形式配置多个，按照数组从后往前链式调用每一个 loader，前一个返回的内容作为下一个的入参。
  - webpack 基于发布订阅模式，其中 compiler 和 compilation 是 webpack 两个非常核心对象，其中 compiler 暴露了和 webpack 整个生命周期相关的钩子，而 compilation 暴露了与模块和依赖有关粒度更小的时间钩子，plugins 的编写有一定要求：必须是一个函数，或者是一个包含 apply 方法的对象，在执行时会传入 compiler 实例，在实例上选择相应的钩子绑定自己的回调，就可以在钩子触发时获取流程上下文完成相应操作。
- 分包
  - splitChunks
- 说说 SourceMap
  - scourceMap 是一项将编译打包压缩后的代码映射回源代码的技术，压缩后的代码无法定位问题，sourceMap 就可以,Webpack 配置里可以通过 devtool 参数配置
- 模块打包运行原理？
  - 读取 webpack 配置参数
  - 启动 webpack，创建 Compiler 对象并开始解析项目
  - 从入口文件 entry 开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树
  - 对不同文件类型的依赖模块文件使用对应 Loader 进行编译，最终转换为 js 文件
  - 整个过程中 webpack 会通过发布订阅模式，向外抛出一些 hooks，plugins 就可以通过监听这些关键的事件节点，执行插件任务从而达到干预输出结果的目的
  - 每个模块之间的依赖关系，则依赖于抽象语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而循环执行下一个模块的解析
- webpack5 有哪些新东西
  - 优化持久缓存，缓存实现增量编译；优化长期缓存，Webpack 5 针对 moduleId 和 chunkId 的计算方式进行了优化，增加确定性的 moduleId 和 chunkId 的生成策略，原来 v4 版本是自增 id
  - NodeJS 的 polyfill 脚本被移除
  - 更好的 TreeShaking， 在 v5 中会分析模块 export 与 import 之间的依赖关系
  - 模块联邦，可以解决跨项目的相互依赖

## HTTP 部分

- Cookie，sessionStorage，localStorage 各自特点以及区别
  - Cookie 存放在本地，在客户端与服务间传递，有大小限制不超过 4k，生成时会有过期时间，超过时间失效，如果不设置关闭浏览器失效
  - localStorage 也是存在本地的，大小为 5M，不参与与服务端通信，不手动清除不会失效，有相应的 api 便于操作
  - sessionStorage 也是存在本地，大小为 2.5M 或者 5M，不参与与服务端通信，页面会话期间可用，有相应的 api 便于操作
- Cookie 跟 Session 的特点与区别
  - Cookie 存放于客户端，Session 存放于服务端
  - 存储量不同，Cookie 一般不超过 4kb，并且一个站点一般保存 20 个，Session 虽然没有存放个数限制，但是太多服务器压力大
  - Cookie 存储的数据为 ASCII 码字符串，并且需要编码的方式存储为 Unicode 字符串或者二进制
  - 安全性不同，Cookie 存在客户端，明文传输存在一定风险，Session 存在服务端，对客户端是透明的
  - 有效期不同，Cookie 可以设置过去时间或者关闭窗口就失效，Session 依赖于 JSESSIONID 的 Cookie 过期时间为-1，关闭窗口就失效
  - Cookie 和 Seesion 都不能跨域
- 跨域问题以及解决办法，jsonp 为什么可以跨域
  - 跨域就是协议，域名，端口不同
  - jsonp：利用 script 标签不受同源限制，只支持 get 请求，需要把回调函数名传递给服务端，服务端把数据跟回调函数一并返回，然后执行
  - nginx 反向代理：
  - postMessage：postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信
  - cors：主要是服务端的工作，Access-Control-Allow-Origin 就可以开启 CORS，其中会涉及到 options 请求（预检请求，来检查是否允许跨域）
  - node 代理服务器，服务器向服务器转发不受限制，所以用代理服务器接受请求再转发
  - websocket 协议跨域
  - window.name + iframe：主要依靠 window.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，先在 iframe 中加载跨域链接，在其中设置 name，再调回同域拿到 name，跳回来是因为不同域之间的 iframe，其中对象基本不可访问。
  - document.domain + iframe：主要通过将 domain 提升为主域名来访问不同子域名下的 contentWindow 之类的对象，只能用于二级域名相同的情况下
  - loaction.hash + iframe：主要通过监测 hash 变化来传值
- 浏览器垃圾回收机制
  - 浏览器的 js 具有自动回收垃圾机制，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。如何知道那些变量是没有用的，主要有两种实现方式：标记清除和引用计数，标记清除比较常用。
  - 标记清除：当变量进入环境时，会将这个变量标记为进入环境，离开时，标记为离开环境。垃圾回收器会在运行时给所有存储在内存中的变量加上标记，然后它会去掉环境中的变量，以及被环境中的变量所引用的变量的标记，剩下的就是准备删除的变量，最后垃圾回收器完成内存清除工作，销毁其内存空间
  - 引用计数：跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型赋值给它，这个值的引用次数就是 1，再赋值给另一个变量，引用次数再加，当这个值的引用次数变成 0 时，就说明无法访问它了，就可以将其内存空间回收，这样会存在循环引用的问题，解决办法就是在不使用的时候，将变量设置为 null
  - vue 中比较常见的就是绑定了事件，在页面销毁时并没有解绑
  - V8 中就是采用标记的方法，从根开始遍历所有对象，可以遍历到的是可达的，没有遍历到的不可达，标记完成之后统一清理不可达，频繁回收之后，内存中会出现大量不连续的空间，也叫做内存碎片，最后会进行整理。
  - 什么时候进行垃圾回收？主要策略有分代收集，增量收集，闲时收集。主要说一下分代收集：浏览器将数据分为两种，一种临时对象（比如函数中创建的），一种长久对象（比如全局对象），这两种对应不同的回收策略，V8 把堆分为新生代和老生代，新生代存放临时对象，老生代存放持久对象，并且让副垃圾回收器跟主垃圾回收器负责。主垃圾回收器主要负责老生代，采用标记清除的办法，副垃圾回收器负责新生代垃圾回收，新生代分为对象区域跟空闲区域，新加入的对象放到对象区域，快满的时候进行一次垃圾清理，先对对象区域所有垃圾做标记，标记完后将存活的对象放到空闲区域，复制完后将两个区域对调。
- 浏览器加速硬件加速
  - 硬件加速技术是指：使用 GPU 的硬件能力为帮助渲染网页，主要用来绘制 3D 图形。像具有 css 3d 属性或者透视效果，filter，剪裁，反射等等，构成合成层。
- DNS 是什么？它如何工作的？
  - DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。是应用层协议，通常该协议运行在 UDP 协议之上，使用的是 53 端口号。
  - 查询过程，本地查询是递归查询，依次通过浏览器缓存 —> 本地 hosts 文件 —> 本地 DNS 解析器 —> 本地 DNS 服务器 —> 其他域名服务器请求。接下来的过程就是迭代过程。
  - 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。
  - 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
  - DNS 实现负载平衡？
    - 一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。
    - 当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合
    - 在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。
    - 以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。
  - DNS 为什么使用 UDP 协议作为传输层协议？
    - DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。
    - 为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。
- 介绍一下 Connection:keep-alive
  - HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 KeepAlive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。
  - keep-alive 技术的创建目的，能在多次 HTTP 之前重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销
  - 在 HTTP/1.0 协议中，默认是关闭的，需要在 http 头加入"Connection: Keep-Alive"；http 1.1 中默认启用 Keep-Alive，如果加入"Connection: close"，才关闭。
- https 加密后还能抓到包吗
  - 会被抓包，只不过抓到是乱码，没有密钥看不了
- 浏览器引擎有哪些
  - webkit 内核，Chrome、Safari
  - Gecko 内核，Firefox
  - Trident，IE
- 说一说 HTTP 的请求方法？
  - HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法
  - HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT
  - GET：请求获取 Request-URI 所标识的资源
  - POST： 在 Request-URI 所标识的资源后附加新的数据
  - HEAD： 请求获取由 Request-URI 所标识的资源的响应消息报头
  - PUT： 请求服务器存储一个资源，并用 Request-URI 作为其标识（修改数据）
  - DELETE： 请求服务器删除对应所标识的资源
  - TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断
  - CONNECT： 建立连接隧道，用于代理服务器
  - OPTIONS： 列出可对资源实行的请求方法，用来跨域请求
- get 跟 post 区别
  - 参数存放位置，get 请求参数存放在 URL 中，post 请求放在请求体中
  - 关于安全，post 跟 get 都是 HTTP 请求，都是明文传递，都不够安全
  - 关于编码，get 请求只能进行 URL 编码（ASCII），post 请求支持多种，通过 content-type 设置
  - 关于长度，get 请求通过 URL 传参是由长度限制的，post 没有
  - 关于缓存，GET 请求后浏览器会主动缓存，POST 默认情况下不能。
- options 方法有什么用？
  - OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。
  - 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用 `*` 来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。
  - JS 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。
- 与缓存有关内容，强缓存，协商缓存
  - 若是 http 的 code 码为 304，意味着命中了缓存。
  - 强缓存: Expires、Cache-Control
    - 这两者区别，Expires 是指定过期时间，Cache-Control 是指定多久后过期；同时存在 Cache-Control 起作用，cache-control 主要的属性就是 max-age
  - 协商缓存: Last-Modified、ETag，当强缓存时间过了就是协商缓存
    - Last-Modified，客户端请求资源-》服务器端返回资源与 Last-Modified 字段-》再次请求资源-》浏览器请求头携带字段 If-Modified-Since:服务器返回的最后修改时间-》服务端比较这两个时间，相等返回 304
    - Etag，客户端请求资源-》服务器端返回 ETagd 字段（根据当前文件的内容生成的唯一标识码）-》再次请求资源-》浏览器请求头携带字段 If-None-Match:唯一标识码-》服务器拿 If-None-Match 和服务器中资源当前 ETag 对比 → 相等返回 304 读取缓存，不等说明资源被更新，需要重新请求
    - 区别：last-modified 性能要好，因为其计算方式简单，Etag 需要根据文件内容生成标识码；Etag 优先级高；Last-Modified 在秒级改变的情况下是无法更新的
  - 改进：使用 md5 或者 hash 缓存，改变文件名或者版本号来实现
- 状态码
  - 2XX 代表成功
    - 200 OK 表示客户端请求被服务端正常处理
    - 202 Accept，请求已接收单未处理完成
    - 204 No Content 请求处理完成，但是响应报文中没有主体部分
  - 3XX 重定向
    - 301 永久重定向，表示请求资源已被分配了新的 URL
    - 302 临时重定向，表示资源不是永久被移动，后续可能还会变动
    - 303 See other 表示请求资源应使用 GET 方法定向获取，并且禁止缓存
    - 304 Not Modified 请求资源在服务器端未改变，可直接使用客户端未过期的缓存
    - 307 308 是禁止 POST 变换成 GET 的对应 301 跟 302
  - 4XX
    - 400 bad request 客户端请求语法错误，服务端无法理解
    - 401 一般是用户认证失败，未登录时一般用这个状态码
    - 403 请求的资源被服务器拒绝，没权限时一般用
    - 404 not found 请求的资源未找到
    - 405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过 options 方法来查看服务器允许的访问方法
  - 5XX
    - 500 表示服务器端在执行请求时发生了错误
    - 502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。
    - 503 服务器暂时处于停机维护或者超负载状态，无法响应
- tcp 协议三次握手四次挥手
  - 三次握手
    - 客户端到服务端，服务端确定客户端发送能力正常，服务端接收能力正常
    - 服务端到客户端，客户端确定服务端接受发送能力正常，客户端确认自己接收发送正常
    - 客户端到服务端，服务端确认了客户端接受能力正常，下面就可以开始发送了
  - 四次挥手
    - 客户端发送一个 FIN，表示自己不再发送数据，关闭数据传送
    - 服务端收到后，发回一个 ASK，确认序号为收到的序号加一
    - 服务端关闭与客户端的连接后，发送一个 FIN
    - 客户端回发 ASK 报文确认，并将确认序号设置为收到的序号加一
  - 为什么挥手需要四次，因为客户端发送 FIN 表示自己不在发送请求，但此时服务端数据可能还有未发送完的，并不能决定立即断开连接，需要由上层应用决定，等结束后在发送 FIN 报文，然后客户端回发 ASK
  - 在四次挥手后，客户端还需要进入等待状态（2MSL 的时间），因为最后发送的 ASK 报文服务端可能没收到，如果没收到，服务端会在一定时间后再次发送 FIN 报文，目的就是确保最后 ASK 报文到达服务端
- 短轮询和长轮询的区别？
  - 短轮询：浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。
  - 长轮询的基本思路:
    - 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。
  - 长轮询优缺点：长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。缺点在于，连接挂起也会导致资源的浪费。
- websocket
  - websocket 是一种全双工通信，是建立在 http 基础上的持久化协议，先使用 http 协议进行初始化握手，建立连接后在使用 tcp 读取写入数据
  - websocket 跟 http 关系：都是基于 tcp 的，都是可靠传输协议，都是应用层协议，不同点就是 websocket 是双向的，模拟 socket 协议，http 单向，其次 websocket 需要握手建立连接
  - Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。
- https 相关内容
  - http 缺点，报文明文可能被窃听，不能验证对方身份可能遭伪装，无法验证报文完整性，https 也有缺点，服务器与客户端都需要解密加密，导致通信慢，还有证书的开销。
  - https 是通过 SSL/TLS 进行了加密，端口是 443，而 http 端口是 80，https 去要到 CA 申请证书，基本没有免费证书，https 也是无状态的
  - https 并非应用层的新协议，而是通信接口用 SSL 跟 TLS 代替，http 是直接与 tcp 通信，而 https 就是先与 ssl 通信，再有 ssl 与 tcp 通信
  - SSL 安全套接字协议
  - https 功能：内容加密，身份认证，数据完整性
  - 内容加密
    - 使用共享密钥加密（解密加密用同一个密钥）这种方式不安全一旦密钥被截就很危险。
    - 使用公开密钥加密（非对称密钥）一把公钥任何人可以获得，私有密钥保密存在服务端，公钥加密的内容，只有私钥可以解开，私钥加密的内容，公钥可以解开，缺点就是速度慢
    - 非对称密钥 + 对称密钥，使用公开密钥方式交换后续使用共享密钥时用到的密钥，确保安全使用共享密钥通信，不过这样也存在问题。
  - 身份认证，为了解决内容加密的问题，可以使用数字证书认证机构 CA 和其颁发的公开密钥证书。
    - 服务器把公开密钥交给 CA 登录
    - CA 用私有密钥给服务器公开密钥签名并颁发公钥证书
    - 客户端是有 CA 的公开密钥的，拿着它验证公钥证书数字签名，确认正确性
    - 确认正确后使用这个公开密钥与服务端通信
    - 服务端使用私有密钥解密
  - 数据完整性（数字签名），从报文生成 128 位散列值，然后用共享密钥加密形成数字签名，接收方也从报文中得到散列值，然后用共享密钥解密数字签名，两者一样则确认信息是完整真实的。
- http2 跟 http1 区别优点
  - http2 的主要特点就是：多路复用，头部压缩，服务器推送，请求优先级，性能提升的核心在于二进制分帧层
  - 多路复用：http2 服用 tcp 链接，客户端服务端可以同时发送多个请求或者回应，这些请求或者响应分成了很多流，每个流中可以传输若干消息，这些消息由二进制帧组成，根据帧首部的流标识可以重新组装，也就是 Stream ID，解决了队头阻塞的问题。
  - 头部压缩，http 的头部信息很多是重复的，http2 中把报文头部信息中常见的名和值做成索引，维护一张静态字典，从而达到压缩头部效果。使用 HPACK 算法进行压缩
  - 服务端推送：除了原始请求的资源外，服务端还可以推送额外的资源
  - 请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。
  - 关于二进制帧：tcp 协议中，传输单位是数据报，分为头部跟数据部分，各部分之间文本以换行符分隔，http2 中把数据报两大部分分成了 header frame 和 data frame，并采用二进制编码，每个帧可以分为多个片段帧，而流代表了完整的请求-响应过程，流中输出的数据就是二进制帧，二进制协议解析起来更高效。
- 浏览器渲染过程（从 URL 上输入地址到页面渲染出来的过程）
  - 用户输入：如果是在打开页面基础上输入 URL，首先会执行 beforeunload 事件和 beforeunload 事件，可以进行一些数据清理工作，或者询问是否离开页面
  - URL 请求过程：
    - 首先在本地缓存中查找，是否有缓存该资源
    - 如果有缓存直接返回给浏览器，如果没有缓存，则进入网络请求过程，DNS 服务器解析，获取请求域名的 ip 地址，如果是 https 请求还需要建立安全连接。其中 DNS 也是先查找浏览器缓存，以及 hosts 文件。
    - 接下来利用 ip 地址和服务器建立 tcp 链接，建立连接后浏览器端会构建请求行、请求头等信息，并把和域名相关的 Cookie 等信息加入到请求头中，然后向服务器发送请求信息
    - 请求在到达服务器前，可能还会经过负载均衡服务器，然后假设会返回一个 html
    - 首先浏览器会判断状态码，根据状态码不同，进行操作。200 继续解析，300 的话会重定向，400 或者 500 报错
    - 如果 html 经过 gzip 压缩，还会进行解压，通过文件编码格式知道如何解析
  - 准备渲染进程，默认情况下 chrome 会为每个页面分配一个渲染进程
  - 渲染阶段
    - 文件解码完成后会开始渲染，根据 html 构建 dom 树，有 css 的话会先构建 cssom 树，如果遇到 script 标签，会先看是否存在 async 或者 defer，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。
    - 如果没有 async 或者 defer，js 就会阻塞渲染，等待 js 执行完毕后再继续
    - cssom 树和 dom 树构建完成之后会开始生成 render 树，就是进一步确定布局样式等等
    - 在生成 render 树的过程中就会调用 gpu 绘制，合成图层，显示在屏幕上
  - 注意重绘重排
    - 重绘元素外观发生改变，背景颜色阴影之类的，并不影响布局
    - 重排元素布局发生变化，大小改变，删除元素，内容，调整窗口大小，查询某些属性等等都会导致重排
    - 重排影响是大于重绘的，在操作时要避免读写分离，应当集中操作，集中改变样式，或者将 dom 离线（复制节点在复制节点上操作，或者 fragment 等），还有提升合成层

## 计算机网络部分

- osi7 层结构

  - 应用层
  - 表示层
  - 会话层
  - 传输层
  - 网络层
  - 数据链路层
  - 物理层

- 五层结构
  - 应用层：HTTP 协议，FTF 文件传输，SMTP 邮件
  - 运输层：TCP 传输控制协议，UDP 用户数据报协议
  - 网络层：IP 协议，逻辑寻址
  - 数据链路层：封装成帧
  - 物理层：比特

## 网络安全部分

- CSRF 跨站请求伪造，攻击者诱导受害者进入第三方网站，利用受害者在被攻击网站获取的注册凭证，绕过后台达到冒充受害者并向被攻击网站发起跨站请求，达成某种目的
  - 分类：get 类型，利用图片，post 类型，利用表单提交，链接类型诱导用户点击
  - 特点：一般发生在第三方网站，被攻击网站无法阻止；攻击者是冒用受害者进行操作；一般是跨域的，如果本域又可以直接利用的功能，比如发图发链接，就可以在本站发起攻击，更加危险
  - 防护策略：阻止不明外域请求，同源检测或者 samesite；提交时要求附加本域才能获取的信息，双重 cookie 或者 csrf token
- XXS 跨站脚本，攻击者向 web 页面注入恶意代码，具体流程就是攻击者提交恶意数据，数据没有经过处理，直接展示到页面上，其他用户访问页面
  - 类型：反射型，攻击者构造出特殊 URL，用户点击时服务端将恶意代码取出，并拼在 html 中返回，使得恶意代码被执行、存储型，攻击者将恶意代码提交到数据库中，其他用户访问服务器从数据库中取出并拼接到 html 中，然后执行了恶意代码、Dom Based 型，攻击者在 url 中存放恶意代码，在前端使用 js 进行页面跳转时，就可能执行了恶意代码，或者使用 innerHMTL 插入时，插入了恶意代码等等
  - 预防策略：纯前端渲染，代码与数据隔离；对 HTML 充分转义；cookie 设置 httponly，不让 js 读取；避免 html 拼接；xxs 检测等等

## 数据结构与算法

- 树的深度遍历，广度遍历
- 二叉树

## 开发中其他

- git 基本操作
- 前后端 token 等信息的传递
- 浏览器兼容性问题
- 性能优化问题，为啥可以优化，哪些可以优化
- nginx 了解
