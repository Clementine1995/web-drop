# 优化指南——网络系列

>[从优化到面试装逼指南——网络系列](https://juejin.im/post/6844904045769916423)

从网络方面进行优化：减少请求数或资源大小

## 减少资源体积

### gzip

如何查看请求的资源是否为 gzip 压缩过的：

1. 打开控制面板进入NetWork
2. 右键选取response headers 选择查看Content-Encoding，可以在面板中手动调出

浏览器请求资源指定编码并解析过程：

1.首先浏览器（也就是客户端）发送请求时，通过Accept-Encoding带上自己支持的内容编码格式列表
2.服务端在接收到请求后，从中挑选出一种用来对响应信息进行编码，并通过Content-Encoding来说明服务端选定的编码信息
3.浏览器在拿到响应正文后，依据Content-Encoding进行解压。

Content-Encoding 可选值

+ gzip：表示采用  Lempel-Ziv coding (LZ77) 压缩算法，以及32位CRC校验的编码方式。
+ compress：采用 Lempel-Ziv-Welch (LZW) 压缩算法。这个名称来自UNIX系统的 compress 程序，已弃用
+ deflate：采用 zlib 结构 (在 RFC 1950 中规定)，和 deflate 压缩算法(在 RFC 1951 中规定)。
+ identity：用于指代自身（例如：未经过压缩和修改）。
+ br：表示采用 Brotli 算法的编码方式。

#### 减少资源体积优化

nginx开启

```bash
gzip on;
gzip_min_length 1k; //不压缩临界值，大于1K的才压缩，一般不用改
gzip_comp_level 2; //压缩级别，1-10，数字越大压缩的越细，时间也越长
gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; //进行压缩的文件类型
gzip_disable "MSIE [1-6]\.";//ie兼容性不好所以放弃
```

webpack开启

compression-webpack-plugin 这个插件可以提供功能

```js
const CompressionWebpackPlugin = require('compression-webpack-plugin');
plugins.push(
  new CompressionWebpackPlugin({
    asset: '[path].gz[query]',// 目标文件名
    algorithm: 'gzip',// 使用gzip压缩
    test: new RegExp(
      '\\.(js|css)$' // 压缩 js 与 css
    ),
    threshold: 10240,// 资源文件大于10240B=10kB时会被压缩
    minRatio: 0.8 // 最小压缩比达到0.8时才会被压缩
  })
)
```

webpack的gzip和nginx的有什么关系？

1. nginx没有开启gzip压缩,webpack打包出的.gz文件是用不到的
2. nginx开启了gzip，nginx查找静态资源是否存在已经压缩好的gzip压缩文件，如果没有则自行压缩（消耗cpu但感知比较少）
3. nginx开启gzip压缩,webpack打包出的.gz文件被找到，提前（打包）压缩直接使用，减少了nginx的压缩损耗

gzip是怎么压缩的？

使用"滑动窗口"的方法，来寻找文件中的每一个匹配长度达到最小匹配的串，重复的内容以一个哈希值存储在字典表中并替换到匹配的串上，以此来达到压缩，因此重复度越高的文件可压缩的空间就越大。

### 源文件控制

#### webpack 的 splitChunks

webpack利用splitchunks进行拆包配合一些加载方式，使原本特别大的appjs分成若干个细小的包，待扩展

#### 关于图片

使用 webp 格式，它是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，无损压缩后的WebP比PNG文件少了26％的体积，有损压缩后的WebP图片相比于等效质量指标的JPEG图片减少了25％~34%的体积。但是兼容性窜在问题

#### 启用http2——头部压缩

HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成。一般而言，消息主体都会经过 gzip 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。一个网站内总有多个http请求，而其headers所占的字节也不少,尤其cookie，有些时headers甚至超过了主体大小。

头部压缩是怎么实现的？

## 减少资源请求

### DNS

dns是什么？

是将域名解析为ip，例如访问baidu.com通过dns系统查出他的ip地址，才能访问，主要是ip对于我们用户太难记住，dns做了域名到ip的解析。

在DNS查询过程中，浏览器进入等待，白屏时间过长，如果DNS查询过多，会受到性能影响，因此需要用到DNS缓存。

dns是怎么运作的？

1. 浏览器是否有缓存
2. 操作系统是否缓存，常见的如hosts文件
3. 路由器是否有缓存
4. 域名服务器是否有缓存：根域服务器（.） -> 顶级域名服务器（com）->主域名服务器（baidu.com）

如何优化？

使用 dns-prefetch 例如：

```html
<link rel="dns-prefetch" href="//baidu.com">
```

需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 禁用DNS 预读取能节省每月100亿的DNS查询。

### http协议

#### 多路复用

当一个tcp建立连接之后，http2将多个请求重复利用这个tcp，并且分成多个stream交错传输，慢的请求或者先发送的请求不会阻塞其他请求的返回，最终根据stream的标识再重组返回，类似并发的感觉非并行。

Header 帧必须在 data 帧前面，data 帧依赖 header 帧的信息解析

http2多路复用和http1.x的keep-alive有什么区别？

+ http1.x：它是遵循先进先出，服务端只能按顺序响应请求，所以如果前面的请求没有响应完变灰发生 队头阻塞，造成延迟，同时保持不必要的连接会影响服务器性能，同时浏览器限制了http同时并发的上限。
+ http2：多个请求可以同时发送（不分先后），按序响应，解决1.x的一些问题。

#### 服务推送

服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应，客户端可以通过发送一个 RST_STREAM 帧来中止推送。比如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

### 缓存

若是http的code码为304，意味着命中了缓存。

#### Expires、Cache-Control

### 图片

### 异步加载

### 预加载

## 安全方面
