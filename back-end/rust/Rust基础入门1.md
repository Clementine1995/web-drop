# Rust 基础入门 1

## 变量绑定与解构

### 变量绑定

Rust 中，变量绑定这样写： `let a = "hello world"` 。为何不使用赋值而使用绑定，这涉及到 Rust 最核心的原则——所有权，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量。

### 变量可变性

可以通过 mut 关键字让变量变为可变的，以实现更加灵活的设计。

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

选择可变还是不可变，更多的还是取决于你的使用场景。

#### 变量解构

let 不仅能用于变量绑定，还能进行复杂变量的解构

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

#### 常量与变量之间的差异

- 常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值。
- 常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。

#### 变量遮蔽(shadowing)

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;
    {
      // 在当前的花括号作用域内，对之前的x进行遮蔽
      let x = x * 2;
      println!("The value of x in the inner scope is: {}", x);
    }
    println!("The value of x is: {}", x);
}
// 输出 12 和 6
```

这和 mut 变量的使用是不同的，第二个 let 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 mut 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。

## 基本类型

Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。

基本类型：

- 数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 &str
- 布尔类型： true 和 false
- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
- 单元类型: 即 () ，其唯一的值也是 ()

### 数值类型

#### 整数和浮点数

整数是没有小数部分的数字。下表显示了 Rust 中的内置的整数类型。视架构而定表示取决于计算机 CPU 类型，如果是 64 位的，则其值为 64。

Rust 整型默认使用 i32

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8 位       | i8         | u8         |
| 16 位      | i16        | u16        |
| 32 位      | i32        | u32        |
| 64 位      | i64        | u64        |
| 128-位     | i128       | u128       |
| 视架构而定 | isize      | usize      |

浮点类型数字是带有小数点的数字，有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64。

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];
  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```

浮点数陷阱：浮点数往往是你想要数字的近似表达，浮点数在某些特性上是反直觉的。有着与 JS 中类似的问题， `0.1 + 0.2 !== 0.3`，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

NaN：对于数学上未定义的结果，所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较。出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN。

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
      println!("未定义的数学行为")
    }
}
```

#### 序列(Range)

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5 ，生成从 1 到 4 的连续数字，不包含 5 ； 1..=5 ，生成从 1 到 5 的连续数字，包含 5 ，它的用途很简单，常常用于循环中。序列只允许用于数字或字符类型。

```rust
for i in 1..=5 {
    println!("{}",i);
}
// 输出 1 2 3 4 5
```

#### 有理数和复数

Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

而想使用可以用社区开发出的 Rust 数值库：num

#### 小结

- Rust 拥有相当多的数值类型
- 类型转换必须是显式的
- Rust 的数值上可以使用方法，比如取整：`13.14_f32.round()`

### 字符、布尔、单元类型

#### 字符类型 char

Rust 的字符用 '' 来表示，"" 双引号是字符串，所有的 Unicode 值都可以作为 Rust 字符，占用 4 个字符

#### 布尔 bool

Rust 中的布尔类型有两个可能的值：true 和 false, 布尔值占用内存的大小为 1 个字节

#### 单元类型

单元类型就是 ()，main 函数就返回这个单元类型 ()，常见的 println!() 的返回值也是单元类型 ()

### 语句和表达式

语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值。基于表达式是函数式语言的重要特征，表达式总要返回值。

#### 语句

```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```

由于 let 是语句，因此不能将 let 语句赋值给其它值。但是 let 作为表达式已经是实验功能了，将来可能可以作为表达式使用。

#### 表达式

表达式会进行求值，然后返回一个值。表达式可以成为语句的一部分。**能返回值，它就是表达式**。

注意：表达式不能包含分号，一旦加上分号，它就会变成语句，而不会返回值。

### 函数

#### 函数要点

- 函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -> {}
- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
- 每个函数参数都需要标注类型

#### 函数参数

Rust 是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型

```rust
fn main() {
  another_function(5, 6.1);
}
// 这里去掉 x 或者 y 的任何一个的类型，都会报错
fn another_function(x: i32, y: f32) {
  println!("The value of x is: {}", x);
  println!("The value of y is: {}", y);
}
```

#### 函数返回

在 Rust 中函数就是表达式，因此我们可以把函数的返回值直接赋给调用者。

函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 return 提前返回。

```rust
fn plus_or_substract(x:i32) -> i32 {
  if x > 5 {
    return x - 5
  }
  x + 5
}
fn main() {
  let x = plus_or_substract(5);
  println!("The value of x is: {}", x);
}
```

Rust 中的特殊返回类型

- 无返回值`()`：单元类型 ()，是一个零长度的元组，用来表示一个函数没有返回值
  - 函数没有返回值，那么返回一个 ()
  - 通过 ; 结尾的表达式返回一个 ()
- 永不返回的函数!：当用 ! 作函数返回类型的时候，表示该函数永不返回

```rust
// 永不返回
fn forever() -> ! {
  loop {
    //...
  };
}
```

## 所有权和借用

### 所有权

所有的程序必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，一般有三种流派：

- 垃圾回收机制(GC)：在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- 手动管理内存的分配和释放：在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- 通过所有权来管理内存：编译器在编译时会根据一系列规则进行检查

Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。

#### 栈（Stack）与堆（Heap）

栈：

栈按照顺序存储值并以相反顺序取出值，这也被称作后进先出。增加数据叫做进栈，移出数据则叫做出栈。栈中的所有数据都必须占用已知且固定大小的内存空间

堆与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

堆：

与栈不同，对于大小未知或者可能变化的数据，需要将它存储在堆上。

当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针, 该过程被称为在堆上分配内存，有时简称为 “分配”。

接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。

性能区别：

写入方面：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。

读取方面：得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。

因此，处理器处理和分配在栈上数据会比在堆上的数据更加高效。

所有权与堆栈：

当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统提供的强大保障。

#### 所有权原则

理解了堆栈，接下来看一下关于所有权的规则，首先谨记以下规则：

- Rust 中每一个值都 有且只有 一个所有者(变量)
- 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

变量作用域：

作用域是一个变量在程序中有效的范围, 假如有这样一个变量：

```rust
let s = "hello"
```

变量 s 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。s 变量从声明的点开始直到当前作用域的结束都是有效的：

```rust
{                      // s 在这里无效，它尚未声明
  let s = "hello";   // 从此处起，s 是有效的
  // 使用 s
}                      // 此作用域已结束，s不再有效
```

简而言之，s 从创建伊始就开始有效，然后有效期持续到它离开作用域为止，可以看出，就作用域来说，Rust 语言跟其他编程语言没有区别。

简单介绍 String 类型：

上面已经见过字符串字面值 let s ="hello"，s 是被硬编码进程序里的字符串值（类型为 &str ）。字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：

- 字符串字面值是不可变的，因为被硬编码到程序代码中
- 并非所有字符串的值都能在编写代码时得知

例如，字符串是需要程序运行时，通过用户动态输入然后存储在内存中的，这种情况，字符串字面值就完全无用武之地。 为此，Rust 为我们提供动态字符串类型: String, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。

可以使用下面的方法基于字符串字面量来创建 String 类型：

```rust
let s = String::from("hello");
```

:: 是一种调用操作符，这里表示调用 String 中的 from 方法，因为 String 存储在堆上是动态的，可以这样修改它：

```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() 在字符串后追加字面值
println!("{}", s); // 将打印 `hello, world!`
```

#### 变量绑定背后的数据交互

转移所有权：

Rust 基本类型都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。

```rust
let s1 = String::from("hello");
let s2 = s1;
```

但是对于复杂类型，比如 String 由**存储在栈中的堆指针、字符串长度、字符串容量共同组成**，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存。下面对上面代码中的 let s2 = s1 分成两种情况讨论：

- 拷贝 String 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 String 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响
- 只拷贝 String 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 8 字节的指针、8 字节的长度、8 字节的容量，总计 24 字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是：一个值只允许有一个所有者，而现在这个值（堆上的真实字符串数据）有了两个所有者：s1 和 s2。

假定一个值可以拥有两个所有者，会发生什么呢？

当变量离开作用域后，Rust 会自动调用 drop 函数并清理变量的堆内存。不过由于两个 String 变量指向了同一位置。这就有了一个问题：当 s1 和 s2 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 二次释放（double free） 的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

因此，Rust 这样解决问题：当 s1 赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，s1 在被赋予 s2 后就马上失效了。

所以如果在把 s1 赋予 s2 后，再对 s1 进行访问，就会报错。

如果你在其他语言中听说过术语 浅拷贝(shallow copy) 和 深拷贝(deep copy)，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 s1 无效了，因此这个操作被称为 移动(move)，而不是浅拷贝。上面的例子可以解读为 s1 被移动到了 s2 中。

```rust
fn main() {
    let x: &str = "hello, world";
    let y = x;
    println!("{},{}",x,y);
}
```

而这个例子继续访问 x 并不会报错，因为 x 只是引用了存储在二进制中的字符串 "hello, world"，并没有持有所有权。

克隆(深拷贝)：

首先，Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何自动的复制都不是深拷贝，可以被认为对运行时性能影响较小。

如果我们确实需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的方法。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

拷贝(浅拷贝)：

浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。

Rust 有一个叫做 Copy 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用。

那么什么类型是可 Copy 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则： 任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的。如下是一些 Copy 的类型：

- 所有整数类型，比如 u32。
- 布尔类型，bool，它的值是 true 和 false。
- 所有浮点数类型，比如 f64。
- 字符类型，char。
- 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。
- 引用类型，例如转移所有权中的最后一个例子

#### 函数传值与返回

将值传递给函数，一样会发生 移动 或者 复制，就跟 let 语句一样，下面的代码展示了所有权、作用域的规则：

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域
    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效
    let x = 5;                      // x 进入作用域
    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x
} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作
fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放
fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

同样的，函数返回值也有所有权，例如:

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1
    let s2 = String::from("hello");     // s2 进入作用域
    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃
fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数
    let some_string = String::from("hello"); // some_string 进入作用域.
    some_string                              // 返回 some_string 并移出给调用的函数
}
// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
    a_string  // 返回 a_string 并移出给调用的函数
}
```

## 引用与借用

如果仅仅支持通过转移所有权的方式获取一个值，那会让程序变得复杂。 Rust 能否像其它编程语言一样，使用某个变量的指针或者引用呢？答案是可以。

Rust 通过 借用(Borrowing) 这个概念来达成上述的目的，获取变量的引用，称之为借用(borrowing)。

### 引用与解引用

常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个 i32 值的引用 y，然后使用解引用运算符来解出 y 所使用的值:

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

变量 x 存放了一个 i32 值 5。y 是 x 的一个引用。可以断言 x 等于 5。然而，如果希望对 y 的值做出断言，必须使用 `*y` 来解出引用所指向的值（也就是解引用）。一旦解引用了 y，就可以访问 y 所指向的整型值并可以与 5 做比较。

### 不可变引用

下面的代码，我们用 s1 的引用作为参数传递给 calculate_length 函数，而不是把 s1 的所有权转移给该函数：

```rust
fn main() {
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
  s.len()
}
```

能注意到两点：

- 无需像上章一样：先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁
- calculate_length 的参数 s 类型从 String 变为 &String

这里，& 符号即是引用，它们允许你使用值，但是不获取所有权，通过 &s1 语法，我们创建了一个指向 s1 的引用，但是并不拥有它。

同理，函数 calculate_length 使用 & 来表明参数 s 的类型是一个引用

但是注意：正如变量默认不可变一样，引用指向的值默认也是不可变的。所以如果在 calculate_length 中使用 `push_str(", world")` 这样的操作时会报错的。

### 可变引用

只需要一个小调整，即可修复上面代码的错误：

```rust
// 首先，声明 s 是可变类型，其次创建一个可变的引用 &mut s 和接受可变引用的函数 some_string: &mut String。
fn main() {
  let mut s = String::from("hello");
  change(&mut s);
}
fn change(some_string: &mut String) {
  some_string.push_str(", world");
}
```

#### 可变引用同时只能存在一个

不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制：**同一作用域**，特定数据只能有一个可变引用。

这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：

- 两个或更多的指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

如果非要使用可以使用大括号，限制变量的作用域

#### 可变引用与不可变引用不能同时存在

其实这个也很好理解，正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。

注意，引用的作用域 s 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 `}`

```rust
fn main() {
   let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    // 新编译器中，r1,r2作用域在这里结束

    let r3 = &mut s;
    println!("{}", r3);
} // 老编译器中，r1、r2、r3作用域在这里结束
  // 新编译器中，r3作用域在这里结束
```

在老版本的编译器中（Rust 1.31 前），将会报错，因为 r1 和 r2 的作用域在花括号 } 处结束，那么 r3 的借用就会触发 无法同时借用可变和不可变的规则。

但是在新的编译器中，该代码将顺利通过，因为 引用作用域的结束位置从花括号变成最后一次使用的位置，因此 r1 借用和 r2 借用在 println! 后，就结束了，此时 r3 可以顺利借用到可变引用。

### NLL

对于这种编译器优化行为，Rust 专门起了一个名字 —— Non-Lexical Lifetimes(NLL)，专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。

### 悬垂引用(Dangling References)

悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。

在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器可以确保数据不会在其引用之前被释放，要想释放数据，必须先停止其引用的使用。

```rust
fn main() {
    let reference_to_nothing = dangle();
}
fn dangle() -> &String {
    let s = String::from("hello");
    &s
}
// 会报错
// this function's return type contains a borrowed value, but there is no value for it to be borrowed from.
// 该函数返回了一个借用的值，但是已经找不到它所借用值的来源
```

因为 s 是在 dangle 函数内创建的，当 dangle 的代码执行完毕后，s 将被释放, 但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 String，这可不对！其中一个很好的解决方法是直接返回 String，最终 String 的 所有权被转移给外面的调用者。
