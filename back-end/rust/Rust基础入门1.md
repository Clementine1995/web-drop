# Rust 基础入门 1

## 变量绑定与解构

### 变量绑定

Rust 中，变量绑定这样写： `let a = "hello world"` 。为何不使用赋值而使用绑定，这涉及到 Rust 最核心的原则——所有权，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量。

### 变量可变性

可以通过 mut 关键字让变量变为可变的，以实现更加灵活的设计。

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

选择可变还是不可变，更多的还是取决于你的使用场景。

#### 变量解构

let 不仅能用于变量绑定，还能进行复杂变量的解构

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

#### 常量与变量之间的差异

- 常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值。
- 常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。

#### 变量遮蔽(shadowing)

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;
    {
      // 在当前的花括号作用域内，对之前的x进行遮蔽
      let x = x * 2;
      println!("The value of x in the inner scope is: {}", x);
    }
    println!("The value of x is: {}", x);
}
// 输出 12 和 6
```

这和 mut 变量的使用是不同的，第二个 let 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 mut 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。

## 基本类型

Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。

基本类型：

- 数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 &str
- 布尔类型： true 和 false
- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
- 单元类型: 即 () ，其唯一的值也是 ()

### 数值类型

#### 整数和浮点数

整数是没有小数部分的数字。下表显示了 Rust 中的内置的整数类型。视架构而定表示取决于计算机 CPU 类型，如果是 64 位的，则其值为 64。

Rust 整型默认使用 i32

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8 位       | i8         | u8         |
| 16 位      | i16        | u16        |
| 32 位      | i32        | u32        |
| 64 位      | i64        | u64        |
| 128-位     | i128       | u128       |
| 视架构而定 | isize      | usize      |

浮点类型数字是带有小数点的数字，有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64。

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];
  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```

浮点数陷阱：浮点数往往是你想要数字的近似表达，浮点数在某些特性上是反直觉的。有着与 JS 中类似的问题， `0.1 + 0.2 !== 0.3`，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

NaN：对于数学上未定义的结果，所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较。出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN。

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
      println!("未定义的数学行为")
    }
}
```

#### 序列(Range)

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5 ，生成从 1 到 4 的连续数字，不包含 5 ； 1..=5 ，生成从 1 到 5 的连续数字，包含 5 ，它的用途很简单，常常用于循环中。序列只允许用于数字或字符类型。

```rust
for i in 1..=5 {
    println!("{}",i);
}
// 输出 1 2 3 4 5
```

#### 有理数和复数

Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

而想使用可以用社区开发出的 Rust 数值库：num

#### 小结

- Rust 拥有相当多的数值类型
- 类型转换必须是显式的
- Rust 的数值上可以使用方法，比如取整：`13.14_f32.round()`

### 字符、布尔、单元类型

#### 字符类型 char

Rust 的字符用 '' 来表示，"" 双引号是字符串，所有的 Unicode 值都可以作为 Rust 字符，占用 4 个字符

#### 布尔 bool

Rust 中的布尔类型有两个可能的值：true 和 false, 布尔值占用内存的大小为 1 个字节

#### 单元类型

单元类型就是 ()，main 函数就返回这个单元类型 ()，常见的 println!() 的返回值也是单元类型 ()

### 语句和表达式

语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值。基于表达式是函数式语言的重要特征，表达式总要返回值。

#### 语句

```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```

由于 let 是语句，因此不能将 let 语句赋值给其它值。但是 let 作为表达式已经是实验功能了，将来可能可以作为表达式使用。

#### 表达式

表达式会进行求值，然后返回一个值。表达式可以成为语句的一部分。**能返回值，它就是表达式**。

注意：表达式不能包含分号，一旦加上分号，它就会变成语句，而不会返回值。

### 函数

#### 函数要点

- 函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -> {}
- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
- 每个函数参数都需要标注类型

#### 函数参数

Rust 是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型

```rust
fn main() {
  another_function(5, 6.1);
}
// 这里去掉 x 或者 y 的任何一个的类型，都会报错
fn another_function(x: i32, y: f32) {
  println!("The value of x is: {}", x);
  println!("The value of y is: {}", y);
}
```

#### 函数返回

在 Rust 中函数就是表达式，因此我们可以把函数的返回值直接赋给调用者。

函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 return 提前返回。

```rust
fn plus_or_substract(x:i32) -> i32 {
  if x > 5 {
    return x - 5
  }
  x + 5
}
fn main() {
  let x = plus_or_substract(5);
  println!("The value of x is: {}", x);
}
```

Rust 中的特殊返回类型

- 无返回值`()`：单元类型 ()，是一个零长度的元组，用来表示一个函数没有返回值
  - 函数没有返回值，那么返回一个 ()
  - 通过 ; 结尾的表达式返回一个 ()
- 永不返回的函数!：当用 ! 作函数返回类型的时候，表示该函数永不返回

```rust
// 永不返回
fn forever() -> ! {
  loop {
    //...
  };
}
```

## 所有权和借用

### 所有权

所有的程序必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，一般有三种流派：

- 垃圾回收机制(GC)：在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- 手动管理内存的分配和释放：在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- 通过所有权来管理内存：编译器在编译时会根据一系列规则进行检查

Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。

#### 栈（Stack）与堆（Heap）

栈按照顺序存储值并以相反顺序取出值，这也被称作后进先出。增加数据叫做进栈，移出数据则叫做出栈。栈中的所有数据都必须占用已知且固定大小的内存空间

堆与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。
